import fnmatch
import os
import sys

from RetrieveLineCoverageFromCloverXML import CloverXMLReportParser
from RetrieveLineCoverageFromCloverDB import CloverDBParser


class Mutant(object):
    def __init__(self):
        self.id = None
        self.type = None
        self.isSubsuming = False
        self.isProbablySubsuming = False
        self.isRedundant = False
        self.isProbablyRedundant = False
        self.path = None
        self.cuPath = None
        self.executionCount = -1
        self.coveringTestsCount = -1
        self.lineNumber = -1
        self.failedTests = set()
        self.coveringTests = set()
        self.subsumedby = set()
        self.subsumes = set()
        self.probablySubsumes = set()
        self.probablySubsumedby = set()
        # self.redundant = set()

    def getCoverageInfo(self, cloverXMLReportParserInstance, cloverDBParserInstance):
        assert isinstance(cloverXMLReportParserInstance, CloverXMLReportParser)
        assert isinstance(cloverDBParserInstance, CloverDBParser)
        assert self.lineNumber >= 0
        self.executionCount = int(cloverXMLReportParserInstance.findCoverage(self.cuPath, self.lineNumber))
        self.coveringTestsCount = int(cloverDBParserInstance.findCoverage(self.cuPath, self.lineNumber))
        self.coveringTests = set(cloverDBParserInstance.findCoveringTests(self.cuPath, self.lineNumber))

    def getBuildResultFilePath(self):
        return ".txt".join(self.path.rsplit('.java', 1))

    def outputForWeka(self):
        return ",".join(str(x) for x in [self.isSubsuming, self.isRedundant, self.type, self.executionCount, self.coveringTestsCount])

    def __str__(self):
        return " ".join(str(x) for x in ["Mutant ", self.id, "| File:", os.path.basename(self.cuPath), "| Subsuming:",
                                         self.isSubsuming,  "| Redundant:", self.isRedundant, "| Covered:", self.executionCount])

    def __repr__(self):
        return self.__str__()


class MutantSet(object):
    def __init__(self, globalPath, coverageReportPath, coverageDBPath, javaHandler):
        self.globalPath = globalPath
        self.coverageReportPath = coverageReportPath
        self.coverageDBPath = coverageDBPath
        self.mutants = list()
        self.filteredMutants = list()
        self.redundancyClusters = dict()
        self.redundancyClustersFromCoverage = dict()

        assert os.path.exists(coverageReportPath)
        assert os.path.exists(coverageDBPath)

        self.cloverXMLReportParserInstance = CloverXMLReportParser(coverageReportPath)
        self.cloverDBParserInstance = CloverDBParser(coverageDBPath, javaHandler)

    def outputForWeka(self, skipHeader=False):
        lines = list()
        if not skipHeader:
            lines.append("\n\n% generated by FindSubsumingRelation script %")
            lines.append("% (c) 2016 Ali Parsai --- www.parsai.net    %")
            lines.append("\n\n\n")
            lines.append("@relation \'subsuming\'")
            lines.append("@attribute \'IsSubsuming\' { \'True\', \'False\' }")
            lines.append("@attribute \'IsRedundant\' { \'True\', \'False\' }")
            lines.append("@attribute \'MutantType\' { \'arithmeticOperatorReplacementBinary\', \'arithmeticOperatorReplacementShortcut\', \'arithmeticOperatorReplacementUnary\', \'logicalOperatorReplacement\', \'shiftOperatorReplacement\', \'relationalOperatorReplacement\', \'conditionalOperatorReplacement\', \'conditionalOperatorDeletion\', \'assignmentOperatorReplacementShortcut\' }")
            lines.append("@attribute \'TimesCovered\' numeric")
            lines.append("@attribute \'NumberOfFailedTests\' numeric")
            lines.append("\n\n@data\n")

        for mutant in self.filteredMutants:
            lines.append(mutant.outputForWeka())

        return "\n".join(lines)

    def retrieveMutants(self):
        for root, dirnames, filenames in os.walk(self.globalPath):
            for filename in fnmatch.filter(filenames, "*.java"):
                if str(filename) == "original.java":
                    continue
                newMutant = Mutant()
                newMutant.path = os.path.relpath(os.path.join(root, filename), self.globalPath)
                newMutant.cuPath = os.path.dirname(newMutant.path)
                newMutant.id = int(str(filename).rsplit(".java", 1)[0])

                with open(os.path.join(root, filename), "r") as mutantHandle:
                    mutantContent = mutantHandle.readlines()

                mutantLine = None
                for line in mutantContent:
                    if "----> line number in original file:" in line:
                        mutantLine = line
                        break

                assert mutantLine is not None
                newMutant.lineNumber = int(mutantLine.rsplit(":", 1)[1])

                mutantLine = None
                for line in mutantContent:
                    if "mutant type: " in line:
                        mutantLine = line
                        break

                assert mutantLine is not None
                newMutant.type = str(mutantLine.rsplit(": ", 1)[1]).strip()

                newMutant.getCoverageInfo(self.cloverXMLReportParserInstance, self.cloverDBParserInstance)

                self.mutants.append(newMutant)

    def retrieveFailedTestResults(self):

        for mutant in self.mutants:
            assert isinstance(mutant, Mutant)
            record = False
            failedTestResultList = list()
            with open(os.path.join(self.globalPath, mutant.getBuildResultFilePath()), "rU") as buildResultFileHandle:
                for line in buildResultFileHandle:

                    if "Tests run:" in line:
                        record = False

                    if record:
                        strippedLine = line.strip().split(':')[0]
                        if ' ' not in strippedLine and "test" in strippedLine.lower():
                            failedTestResultList.append(strippedLine)

                    if ("Failed tests:" in line) or ("Tests in error:" in line):
                        record = True

            mutant.failedTests = set(failedTestResultList)

    def assignStatus(self):
        self.retrieveFailedTestResults()

        for mutant1 in self.mutants:
            for mutant2 in self.mutants:
                assert isinstance(mutant1, Mutant)
                assert isinstance(mutant2, Mutant)
                if mutant1 is mutant2 or len(mutant1.failedTests) == 0 or len(mutant2.failedTests) == 0:
                    continue

                if mutant1.failedTests < mutant2.failedTests:
                    mutant1.subsumes.add(mutant2)
                    mutant2.subsumedby.add(mutant1)

                if mutant1.failedTests == mutant2.failedTests:
                    if self.redundancyClusters.has_key(frozenset(mutant1.failedTests)):
                        assert isinstance(self.redundancyClusters[frozenset(mutant1.failedTests)], set)
                        self.redundancyClusters[frozenset(mutant1.failedTests)].add(mutant1)
                        self.redundancyClusters[frozenset(mutant1.failedTests)].add(mutant2)

                    else:
                        self.redundancyClusters[frozenset(mutant1.failedTests)] = {mutant1, mutant2}

                    mutant1.isRedundant = True
                    mutant2.isRedundant = True

        for mutant in self.mutants:
            assert isinstance(mutant, Mutant)
            if len(mutant.subsumedby) == 0:
                mutant.isSubsuming = True

    def predictStatus(self):
        for mutant1 in self.mutants:
            for mutant2 in self.mutants:
                assert isinstance(mutant1, Mutant)
                assert isinstance(mutant2, Mutant)
                if mutant1 is mutant2 or len(mutant1.coveringTests) == 0 or len(mutant2.coveringTests) == 0:
                    continue

                if mutant1.coveringTests < mutant2.coveringTests:
                    mutant1.probablySubsumes.add(mutant2)
                    mutant2.probablySubsumedby.add(mutant1)

                if mutant1.coveringTests == mutant2.coveringTests:
                    if self.redundancyClustersFromCoverage.has_key(frozenset(mutant1.coveringTests)):
                        assert isinstance(self.redundancyClustersFromCoverage[frozenset(mutant1.coveringTests)], set)
                        self.redundancyClustersFromCoverage[frozenset(mutant1.coveringTests)].add(mutant1)
                        self.redundancyClustersFromCoverage[frozenset(mutant1.coveringTests)].add(mutant2)

                    else:
                        self.redundancyClustersFromCoverage[frozenset(mutant1.coveringTests)] = {mutant1, mutant2}

                    mutant1.isProbablyRedundant = True
                    mutant2.isProbablyRedundant = True

        for mutant in self.mutants:
            assert isinstance(mutant, Mutant)
            if len(mutant.probablySubsumedby) == 0:
                mutant.isProbablySubsuming = True

    def filterMutants(self):
        for mutant in self.mutants:
            assert isinstance(mutant, Mutant)
            if not len(mutant.failedTests) == 0 and not mutant.isRedundant:
                self.filteredMutants.append(mutant)

        for cluster in self.redundancyClusters.values():
            assert isinstance(cluster, set)
            checkedCUs = set()
            for mutant in cluster:
                assert isinstance(mutant, Mutant)
                if mutant.cuPath not in checkedCUs:
                    checkedCUs.add(mutant.cuPath)
                    assert mutant not in self.filteredMutants
                    self.filteredMutants.append(mutant)


mutantSet = MutantSet(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])
mutantSet.retrieveMutants()
mutantSet.assignStatus()
mutantSet.predictStatus()

# mutantSet.filterMutants()
# print "\n".join([str(x) for x in mutantSet.filteredMutants])

if len(sys.argv) == 6 and sys.argv[5] == "skip":
    skipHeaders = True
else:
    skipHeaders = False

# print mutantSet.outputForWeka(skipHeaders)

truePositiveSubsuming = 0
trueNegativeSubsuming = 0
falsePositiveSubsuming = 0
falseNegativeSubsuming = 0


truePositiveRedundant = 0
trueNegativeRedundant = 0
falsePositiveRedundant = 0
falseNegativeRedundant = 0


for mutant in mutantSet.mutants:
    assert isinstance(mutant, Mutant)
    if mutant.isProbablySubsuming and mutant.isSubsuming:
        truePositiveSubsuming += 1
    elif mutant.isProbablySubsuming and not mutant.isSubsuming:
        falsePositiveSubsuming += 1
    elif not mutant.isProbablySubsuming and mutant.isSubsuming:
        falseNegativeSubsuming += 1
    elif not mutant.isProbablySubsuming and not mutant.isSubsuming:
        trueNegativeSubsuming += 1

    if mutant.isProbablyRedundant and mutant.isRedundant:
        truePositiveRedundant += 1
    elif mutant.isProbablyRedundant and not mutant.isRedundant:
        falsePositiveRedundant += 1
    elif not mutant.isProbablyRedundant and mutant.isRedundant:
        falseNegativeRedundant += 1
    elif not mutant.isProbablyRedundant and not mutant.isRedundant:
        trueNegativeRedundant += 1

totalMutants = len(mutantSet.mutants)
assert totalMutants == truePositiveSubsuming + falsePositiveSubsuming + trueNegativeSubsuming + falseNegativeSubsuming
assert totalMutants == truePositiveRedundant + falsePositiveRedundant + trueNegativeRedundant + falseNegativeRedundant

precisionSubsuming = 100 * truePositiveSubsuming / float(truePositiveSubsuming + falsePositiveSubsuming)
recallSubsuming = 100 * truePositiveSubsuming / float(truePositiveSubsuming + falseNegativeSubsuming)
accuracySubsuming = 100 * (truePositiveSubsuming + trueNegativeSubsuming) / float(totalMutants)

precisionRedundant = 100 * truePositiveRedundant / float(truePositiveRedundant + falsePositiveRedundant)
recallRedundant = 100 * truePositiveRedundant / float(truePositiveRedundant + falseNegativeRedundant)
accuracyRedundant = 100 * (truePositiveRedundant + trueNegativeRedundant) / float(totalMutants)

print "Subsuming Prediction:", len(mutantSet.mutants), "\nTP:", truePositiveSubsuming, " FP:", falsePositiveSubsuming, "\nFN:", falseNegativeSubsuming, "TN:", trueNegativeSubsuming
print "----------------------------\nPrecision: %.2f" % precisionSubsuming, "\nRecall: %.2f" % recallSubsuming, "\nAccuracy: %.2f" % accuracySubsuming,  "\n****************************"


print "Redundant Prediction:", len(mutantSet.mutants), "\nTP:", truePositiveRedundant, " FP:", falsePositiveRedundant, "\nFN:", falseNegativeRedundant, "TN:", trueNegativeRedundant
print "----------------------------\nPrecision: %.2f" % precisionRedundant, "\nRecall: %.2f" % recallRedundant, "\nAccuracy: %.2f" % accuracyRedundant, "\n****************************"

# for mutant in mutantSet.mutants:
#     assert isinstance(mutant, Mutant)
#     print "*****************************"
#     print mutant.failedTests, mutant.coveringTests
#     print "*****************************"